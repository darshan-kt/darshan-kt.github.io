<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Plate Cleaning Robot using ABB IRB 120</title>
  <!-- Link your main stylesheet -->
  <link rel="stylesheet" href="style.css">
  <!-- Optional: Include Font Awesome / Google Fonts -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    /* Report container using the default dark theme */
    .report-container {
      max-width: 800px;
      margin: 2rem auto;
      padding: 2rem;
      background: #1a1a1a; /* Dark grey background */
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      line-height: 1.6;
      color: #fff;
    }
    .report-container h1,
    .report-container h2,
    .report-container h3 {
      text-align: left;
      margin-bottom: 1rem;
      color: #1db954; /* Spotify green */
    }
    .report-container p,
    .report-container li,
    .report-container pre {
      text-align: justify;
      margin-bottom: 1rem;
      color: #fff;
    }
    .report-container ul,
    .report-container ol {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }
    .report-container figure {
      margin: 1.5rem 0;
      text-align: center;
    }
    .report-container figcaption {
      font-size: 0.9rem;
      color: #aaa;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <!-- Navigation Bar (uses default styling from style.css) -->
  <nav>
    <div class="container">
      <a href="index.html" class="logo">Jerin Peter</a>
      <ul class="nav-links">
        <li><a href="index.html#projects">Projects</a></li>
        <li><a href="index.html#experience">Experience</a></li>
        <li><a href="index.html#publications">Publications</a></li>
        <li><a href="index.html#contact">Contact</a></li>
      </ul>
    </div>
  </nav>

  <!-- Report Content -->
  <div class="report-container">
    <h1>Implementation of a Plate Cleaning Robot using ABB IRB 120</h1>
    <p><em>A Comprehensive Approach to Dishwashing Automation</em></p>

    <h2>Abstract</h2>
    <p>
      This paper presents a comprehensive implementation of a plate cleaning robot utilizing the ABB IRB 120 robotic arm.
      The robot mimics human dishwashing motions through a sophisticated spiral trajectory, ensuring thorough cleaning of
      plates placed randomly within a predefined workspace. The system leverages numerical inverse kinematics (IK) and
      Proportional-Derivative (PD) control strategies for precise end-effector positioning and trajectory following.
      Detailed explanations of the task space definition, plate position generation, trajectory planning, and control methodologies are
      provided, highlighting the complexity and intricacies involved in developing such a robotic system.
    </p>
    <p><strong>Index Terms:</strong> robotics, inverse kinematics, PD control, trajectory planning, automation</p>

    <h2>I. Introduction</h2>
    <p>
      The automation of routine tasks, such as dishwashing, has seen significant advancements with the integration of robotic
      systems. This report delves into the meticulous implementation of a robotic system designed to mimic human dishwashing
      motions. The ABB IRB 120 robotic arm is employed in this project to perform dishwashing tasks by executing a spiral
      motion to clean plates, emulating human-like washing techniques. This report provides detailed explanations of the system’s
      components, including task space definition, inverse kinematics, control strategies, and trajectory planning.
    </p>

    <h2>II. System Overview</h2>
    <p>
      The robotic system comprises an ABB IRB 120 robotic arm programmed to navigate a defined workspace, identify plate positions,
      and perform cleaning operations. The core components of the system include the inverse kinematics method, task space
      boundaries, plate position generation, and control strategies.
    </p>

    <h3>A. System Flowchart</h3>
    <figure>
      <img src="assets/images/projects/arm_project/fig1.png" alt="System Flowchart" style="max-width: 400px; width: 100%;">
      <figcaption>Fig. 1. System Flowchart</figcaption>
    </figure>

    <h3>B. Inverse Kinematics Method</h3>
    <p>
      Inverse kinematics (IK) is pivotal in determining the required joint angles for the robotic arm to achieve a specific
      end-effector position and orientation. The numerical IK method is chosen for its robustness in handling the complex
      configurations of the robotic arm. The IK problem is formulated as:
    </p>
    <pre><code>Find q such that T(q) = Td</code></pre>
    <p>
      where <em>q</em> is the vector of joint angles, <em>T(q)</em> is the transformation matrix representing the end-effector pose,
      and <em>Td</em> is the desired end-effector pose.
    </p>

    <h3>C. Task Space Definition</h3>
    <p>
      The task space is defined to exclude the robot’s base area, ensuring safe operation. The boundaries are set as follows:
    </p>
    <ul>
      <li>X-axis: <em>xmin</em> = 0.0 m, <em>xmax</em> = 0.32 m</li>
      <li>Y-axis: <em>ymin</em> = –0.38 m, <em>ymax</em> = 0.32 m</li>
      <li>Z-axis: <em>zplate</em> = 0.03 m (fixed plate height)</li>
    </ul>

    <h3>D. Plate Position Generation</h3>
    <p>
      A function is employed to generate random plate positions within the task space. The generated positions must ensure
      no overlap between plates and maintain a minimum distance from the robot’s base. This is achieved through the following steps:
    </p>
    <ol>
      <li><strong>Random Position Generation:</strong> A new position <em>Pnew</em> is generated within the task space boundaries.</li>
      <li><strong>Distance Calculation:</strong> The Euclidean distances between <em>Pnew</em> and existing plate positions <em>Pi</em> are calculated.</li>
      <li><strong>Validation:</strong> The new position is validated if the distances satisfy the minimum distance constraint
          (<em>minDistance</em> = 0.28 m) and the distance from the base (<em>baseRadius</em> = 0.25 m).</li>
    </ol>

    <h2>III. Control and Motion Planning</h2>
    <p>
      The robot’s motion planning involves two primary phases: cleaning the plates using a spiral trajectory and transitioning
      between plates.
    </p>

    <h3>A. Spiral Trajectory for Cleaning</h3>
    <ol>
      <li>
        <strong>Parameters Definition:</strong>
        <ul>
          <li>Number of points (<em>npoints</em>): 55</li>
          <li>Radius (<em>r</em>): 0.145 m</li>
          <li>Number of turns (<em>nturns</em>): 3</li>
          <li>Height above plate (<em>zabove plate</em>): 0.05 m</li>
        </ul>
      </li>
      <li>
        <strong>Trajectory Equations:</strong>
        <pre><code>
θ = linspace(0, 2π · nturns, npoints)
ri = linspace(0, r, npoints)
xi = ri cos(θi) + xplate
yi = ri sin(θi) + yplate
zi = zplate + zabove plate
        </code></pre>
      </li>
    </ol>

    <h3>B. Transition Trajectory</h3>
    <p>
      Transitioning between plates requires generating smooth trajectories that avoid collisions with the robot’s base and other obstacles.
      This is achieved using a cubic polynomial trajectory planning method, which ensures smooth acceleration and deceleration phases.
    </p>
    <ol>
      <li><strong>Waypoints Definition:</strong> Define intermediate waypoints that guide the robot around the base, avoiding obstacles.</li>
      <li><strong>Midpoint Angle Calculation:</strong> Calculate angles for the waypoints using the <code>atan2</code> function.</li>
      <li><strong>Shortest Arc Calculation:</strong> Determine the shortest arc between angles.</li>
      <li><strong>Midpoint Waypoints:</strong> Create intermediate waypoints along the arc at a safe distance from the base.</li>
      <li><strong>Trajectory Planning:</strong> Use a cubic polynomial method (e.g., <code>cubicpolytraj</code> in MATLAB) to generate the trajectory.</li>
    </ol>

    <h2>IV. Trajectory Generation</h2>
    <h3>A. Cleaning Trajectory</h3>
    <p>
      The spiral trajectory for cleaning is generated using a parametric approach, where the radius increases linearly with the
      angle to form a spiral:
    </p>
    <pre><code>
xi = ri cos(θi) + xplate
yi = ri sin(θi) + yplate
zi = zplate + zabove plate
    </code></pre>

    <h3>B. Transition Trajectory</h3>
    <p>
      The transition trajectory ensures smooth movement from one plate to another. It is defined by planning the robot’s motion between intermediate waypoints:
    </p>
    <pre><code>
p(t) = a3 t³ + a2 t² + a1 t + a0
    </code></pre>
    <p>
      where <em>p(t)</em> is the position at time <em>t</em> and the coefficients are determined by the initial and final conditions.
    </p>

    <h2>V. Experimental Setup and Results</h2>
    <h3>A. Initial Setup</h3>
    <p>
      The robot starts at the origin with a zero joint configuration. Plates are placed randomly within the task space, ensuring spacing constraints.
    </p>

    <h3>B. Simulation Execution</h3>
    <p>
      The simulation proceeds with the robot identifying the nearest unvisited plate, executing the spiral cleaning motion, and transitioning to the next plate. This loop continues until all plates are cleaned.
    </p>

    <h3>C. Shortest Path Calculation</h3>
    <pre><code>
dist(i) = √((xcurrent - xi)² + (ycurrent - yi)²)
    </code></pre>
    <p>
      The plate with the minimum distance is chosen as the next target.
    </p>

    <h3>D. Visualization</h3>
    <p>
      The simulation provides real-time visualization of the robot’s movements, including spiral and transition trajectories.
    </p>
    <figure>
      <img src="assets/images/projects/arm_project/fig2.png" alt="Spiral and Transition Trajectories" style="max-width: 400px; width: 100%;">
      <figcaption>Fig. 2. Spiral and Transition Trajectories</figcaption>
    </figure>
    <figure>
      <img src="assets/images/projects/arm_project/fig3.png" alt="Spiral Cleaning Trajectory" style="max-width: 400px; width: 100%;">
      <figcaption>Fig. 3. Robot executing the spiral cleaning trajectory on plates</figcaption>
    </figure>
    <figure>
      <img src="assets/images/projects/arm_project/fig4.png" alt="Transition Trajectory" style="max-width: 400px; width: 100%;">
      <figcaption>Fig. 4. Robot transitioning between plates using cubic polynomial trajectory</figcaption>
    </figure>

    <h2>VI. Conclusion</h2>
    <p>
      The robotic system successfully demonstrates dishwashing tasks through a controlled spiral motion. The implementation highlights the effectiveness of numerical IK methods and PD controllers in achieving precise and efficient robotic operations. Future work may include optimizing control parameters and exploring advanced trajectory planning algorithms.
    </p>

    <h2>Acknowledgment</h2>
    <p>
      I, Jerin Peter, the first author, would like to express my gratitude to Professor Jonathan Realmuto for his exceptional guidance and teaching in the Kinematics and Dynamics (ME221) course.
    </p>

    <h2>References</h2>
    <ol>
      <li>MathWorks, “Inverse Kinematics - MATLAB Simulink,” <a href="https://www.mathworks.com/help/robotics/ref/inversekinematics.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Analytical Solutions of the Inverse Kinematics,” <a href="https://www.mathworks.com/help/robotics/ug/solve-closed-form-inverse-kinematics.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Trajectory Control Modeling with Inverse Kinematics,” <a href="https://www.mathworks.com/help/robotics/ref/cubicpolytraj.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Implement PID Control,” <a href="https://www.mathworks.com/help/control/examples/implement-pid-control.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Constraint Objects,” <a href="https://www.mathworks.com/help/robotics/ug/constraint-objects.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Model and Control a Manipulator Arm with Robotics and Simscape,” <a href="https://www.mathworks.com/help/robotics/ug/model-and-control-a-manipulator-arm.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Multi-Loop PI Control of a Robotic Arm,” <a href="https://www.mathworks.com/help/control/ug/multi-loop-pi-control-of-a-robotic-arm.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Connect to Kinova Gen3 Robot and Manipulate the Arm Using MATLAB,” <a href="https://www.mathworks.com/help/robotics/ug/connect-to-kinova-gen3-robot-and-manipulate-the-arm-using-matlab.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Modeling Inverse Kinematics in a Robotic Arm,” <a href="https://www.mathworks.com/help/robotics/ug/modeling-inverse-kinematics-in-a-robotic-arm.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Sliding Mode Control Design for a Robotic Manipulator,” <a href="https://www.mathworks.com/help/robotics/ug/sliding-mode-control-design-for-a-robotic-manipulator.html" target="_blank" style="color: #1db954;">Link</a>.</li>
      <li>MathWorks, “Perform Safe Trajectory Tracking Control Using Robotics Manipulator Blocks,” <a href="https://www.mathworks.com/help/robotics/ug/safe-trajectory-tracking-control.html" target="_blank" style="color: #1db954;">Link</a>.</li>
    </ol>

    <h2>Appendix A: MATLAB Code</h2>
    <p>The MATLAB code used for the simulation is presented below:</p>
    <pre style="background-color: #222; padding: 1rem; overflow-x: auto; color: #fff;">
<code>
clc;
clear all;
close all;

% {’analytic’, ’numeric’, ’generalized’}
ik_method = "numeric";

r = loadrobot('abbIrb120','DataFormat','column');
q0 = zeros(6,1);
q = q0;

% Define task space boundaries (excluding robot’s base area)
x_min = 0.0; x_max = 0.3;
y_min = -0.38; y_max = 0.38;
z_plate = 0.03; % Plate height
minDistance = 0.28; % Minimum distance between plates
baseRadius = 0.25; % Radius of the base exclusion zone

% Number of plates
numPlates = 4;

% Generate random plate positions
generateRandomPosition = @() [x_min + (x_max - x_min)*rand, y_min + (y_max - y_min)*rand, z_plate];
platePositions = zeros(numPlates, 3);
for i = 1:numPlates
    isValid = false;
    while ~isValid
        newPosition = generateRandomPosition();
        distances = sqrt(sum((platePositions(1:i-1,1:2) - newPosition(1:2)).^2, 2));
        distanceFromBase = norm(newPosition(1:2));
        if all(distances > minDistance) && distanceFromBase > baseRadius
            platePositions(i, :) = newPosition;
            isValid = true;
        end
    end
end

% Initialize plot
figure;
ax = show(r, q, 'Visuals','on','PreservePlot',0,'Fastupdate',1);
hold on;
drawFloor();

% Show plates
for idx = 1:numPlates
    PlatePosition = platePositions(idx, :);
    body = rigidBody(['Plate', num2str(idx), '_link']);
    addVisual(body, "Mesh", 'Dinner_Plate_v1.stl', [[0.003*eye(3), zeros(3,1)]; 0 0 0 1]);
    setFixedTransform(body.Joint, trvec2tform(PlatePosition));
    addBody(r, body, r.BaseName);
    show(r, 'Visuals','on','PreservePlot',0,'Frames','off','Parent', ax);
    drawnow;
end

% Inverse Kinematics setup
ik = inverseKinematics('RigidBodyTree', r);
orientation = eul2quat([0, pi/2, 0]); % Ensure the z-axis points down

% PD Controller parameters
Kp = 20; Kd = 0.1; dt = 0.01;
visitedPlates = false(numPlates, 1);
currentPosition = [0, 0, 0];

% Simulation loop for cleaning
for visitCount = 1:numPlates
    distances = sqrt(sum((platePositions(:,1:2) - currentPosition(1:2)).^2, 2));
    distances(visitedPlates) = inf;
    [~, idx] = min(distances);
    PlatePosition = platePositions(idx, :);
    visitedPlates(idx) = true;
    
    % Generate spiral trajectory
    nPoints = 55;
    radius = 0.145; turns = 3;
    theta = linspace(0, 2*pi*turns, nPoints);
    radii = linspace(0, radius, nPoints);
    z_above_plate = 0.05;
    z = ones(1, nPoints)*(z_plate + z_above_plate);
    x = radii.*cos(theta) + PlatePosition(1);
    y = radii.*sin(theta) + PlatePosition(2);
    
    prevError = zeros(6,1);
    for i = 1:nPoints
        Td = trvec2tform([x(i), y(i), z(i)]) * quat2tform(orientation);
        [q_desired, ~] = ik('tool0', Td, ones(6,1), q);
        error = q_desired - q;
        dError = (error - prevError)/dt;
        u = Kp*error + Kd*dError;
        q = q + u*dt;
        prevError = error;
        show(r, q, 'Visuals','on','PreservePlot',0,'Frames','off','Parent', ax);
        drawnow;
    end
    currentPosition = [x(end), y(end), z(end)];
    
    % Transition trajectory if not last plate
    if visitCount < numPlates
        distances = sqrt(sum((platePositions(:,1:2) - currentPosition(1:2)).^2, 2));
        distances(visitedPlates) = inf;
        [~, nextIdx] = min(distances);
        nextPlatePosition = platePositions(nextIdx, :);
        nTransitionPoints = 50;
        transitionTime = linspace(0, 1, nTransitionPoints);
        
        angle1 = atan2(currentPosition(2), currentPosition(1));
        angle2 = atan2(nextPlatePosition(2), nextPlatePosition(1));
        if angle1 < 0, angle1 = angle1 + 2*pi; end
        if angle2 < 0, angle2 = angle2 + 2*pi; end
        if angle2 < angle1, angle2 = angle2 + 2*pi; end
        if (angle2 - angle1) <= (2*pi - (angle2 - angle1))
            midAngles = linspace(angle1, angle2, 5);
        else
            midAngles = linspace(angle1, angle2 - 2*pi, 5);
        end
        midRadius = max(baseRadius + 0.1, 0.3);
        midPoints = [midRadius*cos(midAngles') midRadius*sin(midAngles') repmat(z_above_plate+0.2, length(midAngles), 1)];
        waypoints = [currentPosition; midPoints; nextPlatePosition(1), nextPlatePosition(2), z_plate+z_above_plate];
        waypointsTime = linspace(0, 1, size(waypoints, 1));
        [transitionTraj, ~, ~] = cubicpolytraj(waypoints', waypointsTime, transitionTime);
        xTransition = transitionTraj(1, :);
        yTransition = transitionTraj(2, :);
        zTransition = transitionTraj(3, :);
        
        prevError = zeros(6,1);
        for i = 1:nTransitionPoints
            Td = trvec2tform([xTransition(i), yTransition(i), zTransition(i)]) * quat2tform(orientation);
            [q_desired, ~] = ik('tool0', Td, ones(6,1), q);
            error = q_desired - q;
            dError = (error - prevError)/dt;
            u = Kp*error + Kd*dError;
            q = q + u*dt;
            prevError = error;
            show(r, q, 'Visuals','on','PreservePlot',0,'Frames','off','Parent', ax);
            drawnow;
        end
        currentPosition = [xTransition(end), yTransition(end), zTransition(end)];
    end
end

function drawFloor()
    ax = gca;
    ax.CameraViewAngle = 5;
    p = patch([1 -1 -1 1].*0.5, [1 1 -1 -1].*0.5, [0 0 0 0]);
    p.FaceColor = [0.8, 0.8, 0.8];
    axis off;
    xlim([-0.75, 0.75]);
    ylim([-0.75, 0.75]);
    zlim([0, 0.75]);
end
</code>
    </pre>
  </div>
  
  <!-- Footer -->
  <footer style="text-align: center; padding: 1rem 0; background-color: #000; color: #1db954;">
    <p>&copy; 2025 Jerin Peter. All rights reserved.</p>
  </footer>
</body>
</html>
